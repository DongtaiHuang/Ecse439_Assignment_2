module CPS2URN;
create OUT: URN from IN: CPS;

helper context CPS!Expression def: getCourse() : CPS!Course =
	if self.eContainer().oclIsKindOf(CPS!Course) then
		self.eContainer()
	else
		self.eContainer().getCourse()
	endif;

-- Recursively calculates Y-offsets to prevent overlapping branches!
helper context CPS!Expression def: getYOffset() : Integer =
	if self.eContainer().oclIsKindOf(CPS!Course) then
		0 -- Root of the tree stays in the center
	else if self.eContainer().LHS = self then
		self.eContainer().getYOffset() - 45 -- Push LHS branches up
	else
		self.eContainer().getYOffset() + 45 -- Push RHS branches down
	endif endif;

rule System2URN {
	from
		c: CPS!CPS
	to
		u: URN!URNspec (
			name <- 'Assignment2_Model',
			ucmspec <- ucm,
			urndef <- udef
		),
		udef: URN!URNdefinition (
			urnspec <- u,
			specDiagrams <- Sequence{map1,
						map2,
						map3,
						map4,
						map5}
		),
		ucm: URN!UCMspec (
			urnspec <- u,
			scenarioGroups <- sg,
			variables <- c.courses
		),
		sg: URN!ScenarioGroup (
			name <- 'ScenarioGroup5',
			scenarios <- c.students
		),
		map1: URN!UCMmap (
			name <- 'Year 1',
			urndefinition <- udef
		),
		map2: URN!UCMmap (
			name <- 'Year 2',
			urndefinition <- udef
		),
		map3: URN!UCMmap (
			name <- 'Year 3',
			urndefinition <- udef
		),
		map4: URN!UCMmap (
			name <- 'Year 4',
			urndefinition <- udef
		),
		map5: URN!UCMmap (
			name <- 'Year 5',
			urndefinition <- udef
		)
}

-- RULE 1: Courses WITHOUT Prerequisites (Fully Connected & Labeled!)
rule Course2Elements_NoPrereq {
	from
		c : CPS!Course (c.prerequisites.oclIsUndefined())
	to
		v : URN!Variable ( name <- c.courseNumber, type <- 'boolean' ),
		
		-- 1. The Start Node
		start : URN!StartPoint (
			name <- c.courseNumber,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 100, 
			y <- c.eContainer().courses->select(crs | crs.suggestedYear = c.suggestedYear)->indexOf(c) * 150,
			label <- startLabel
		),
		startLabel : URN!NodeLabel, -- Nudge start label top-left
		
		-- 2. The OrFork
		fork : URN!OrFork (
			name <- 'OrFork_' + c.courseNumber,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 200,
			y <- start.y
		),
		
		-- 3. The "Taken" EndPoint & Label
		endTaken : URN!EndPoint (
			name <- 'taken',
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 300, 
			y <- start.y,
			label <- endTakenLabel
		),
		endTakenLabel : URN!NodeLabel ( deltaX <- 20, deltaY <- -15 ),
		
		-- 4. The "Could Be Taken" EndPoint & Label
		endCould : URN!EndPoint (
			name <- 'could be taken',
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 250, 
			y <- start.y + 50,
			label <- endCouldLabel
		),
		endCouldLabel : URN!NodeLabel,
		
		-- 5. Connection: Start -> Fork
		nc1 : URN!NodeConnection (
			source <- start, target <- fork,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		),
		
		-- 6. Connection: Fork -> Taken (With Offset Condition!)
		nc2 : URN!NodeConnection (
			source <- fork, target <- endTaken,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			condition <- cond1
		),
		cond1 : URN!Condition ( 
			label <- c.courseNumber, 
			expression <- c.courseNumber,
			deltaX <- 30, deltaY <- 20 -- Push text up and right so it clears the line
		),
		
		-- 7. Connection: Fork -> Could Be Taken (With Offset Condition!)
		nc3 : URN!NodeConnection (
			source <- fork, target <- endCould,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			condition <- cond2
		),
		cond2 : URN!Condition ( 
			label <- 'else', expression <- 'else',
			deltaX <- -15, deltaY <- 15 -- Push text down and left for the angled line
		)
}

-- RULE 2: Courses WITH Prerequisites (Fully Routed & Visually Polished!)
rule Course2Elements_WithPrereq {
	from
		c : CPS!Course (not c.prerequisites.oclIsUndefined())
	to
		v : URN!Variable ( name <- c.courseNumber, type <- 'boolean' ),
		
		-- 1. Start Node
		start : URN!StartPoint (
			name <- c.courseNumber,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 100, y <- c.eContainer().courses->select(crs | crs.suggestedYear = c.suggestedYear)->indexOf(c) * 150,
			label <- startLabel
		),
		startLabel : URN!NodeLabel,
		
		-- 2. Final Course Check (Spawns after the AST finishes)
		finalCheck : URN!OrFork (
			name <- 'FinalCheck_' + c.courseNumber,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 600, y <- start.y
		),
		
		-- 3. "Taken" EndPoint (Horizontal, matching NoPrereq)
		endTaken : URN!EndPoint (
			name <- 'taken',
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 700, y <- start.y,
			label <- endTakenLabel
		),
		endTakenLabel : URN!NodeLabel,
		
		-- 4. "Could Be Taken" EndPoint (Tilted down, matching NoPrereq)
		endCould : URN!EndPoint (
			name <- 'could be taken',
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 650, y <- start.y + 50,
			label <- endCouldLabel
		),
		endCouldLabel : URN!NodeLabel ( deltaX <- 20, deltaY <- 15 ),

		-- 5. The Failure Collector (Pulled into the middle of the AST, lower Y)
		failCollector : URN!OrJoin (
			name <- 'FailCollector_' + c.courseNumber,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 350, y <- start.y + 60 
		),
		
		-- 6. "Cannot Be Taken" EndPoint (Tilted down from the Fail Collector)
		endCannot : URN!EndPoint (
			name <- 'cannot be taken',
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString()),
			x <- 400, y <- start.y + 110,
			label <- endCannotLabel
		),
		endCannotLabel : URN!NodeLabel ( deltaX <- 20, deltaY <- 15 ),
		
		-- CONNECTIONS
		ncStart2AST : URN!NodeConnection (
			source <- start, target <- thisModule.resolveTemp(c.prerequisites, 'inNode'),
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		),
		ncAST2Final : URN!NodeConnection (
			source <- thisModule.resolveTemp(c.prerequisites, 'outNode'), target <- finalCheck,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		),
		
		-- Final Check -> Taken
		ncFinalTaken : URN!NodeConnection (
			source <- finalCheck, target <- endTaken, condition <- condTaken,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		),
		condTaken : URN!Condition ( label <- c.courseNumber , expression <- c.courseNumber, deltaX <- 30, deltaY <- -20 ),
		
		-- Final Check -> Could Be Taken
		ncFinalCould : URN!NodeConnection (
			source <- finalCheck, target <- endCould, condition <- condCould,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		),
		condCould : URN!Condition ( label <- 'else', expression <- 'else', deltaX <- -15, deltaY <- 15 ),
		
		-- Fail Collector -> Cannot Be Taken
		ncFail2End : URN!NodeConnection (
			source <- failCollector, target <- endCannot,
			diagram <- thisModule.resolveTemp(c.eContainer(), 'map' + c.suggestedYear.toString())
		)
}

-- 1. The Atomic Node (The Prerequisite Check)
rule Atomic2Nodes {
	from e : CPS!AtomicExpression
	to
		-- Now an OrFork so it can evaluate Yes/No!
		inNode : URN!OrFork (
			name <- 'Check_' + e.course.courseNumber,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 300, y <- e.getCourse().eContainer().courses->select(crs | crs.suggestedYear = e.getCourse().suggestedYear)->indexOf(e.getCourse()) * 150 + e.getYOffset()
		),
		outNode : URN!EmptyPoint (
			name <- 'Pass_' + e.course.courseNumber,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 400, y <- inNode.y
		),
		-- Success Branch (Flows to outNode)
		ncPass : URN!NodeConnection (
			source <- inNode, target <- outNode, condition <- condPass,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		condPass : URN!Condition ( label <- e.course.courseNumber, expression <- e.course.courseNumber, deltaX <- 15, deltaY <- -15 ),
		
		-- Failure Branch (Diverts to the Course's FailCollector!)
		ncFail : URN!NodeConnection (
			source <- inNode, target <- thisModule.resolveTemp(e.getCourse(), 'failCollector'), condition <- condFail,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		condFail : URN!Condition ( label <- 'else', expression <- 'else', deltaX <- -10, deltaY <- 20 )
}

-- 2. The AND Node (Parallel Branches)
rule CompoundAnd2Nodes {
	from e : CPS!CompoundExpression (e.operator = #AND)
	to
		inNode : URN!AndFork (
			name <- 'AndSplit', diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 200, y <- e.getCourse().eContainer().courses->select(crs | crs.suggestedYear = e.getCourse().suggestedYear)->indexOf(e.getCourse()) * 150 + e.getYOffset()
		),
		outNode : URN!AndJoin (
			name <- 'AndMerge', diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 500, y <- inNode.y
		),
		ncLHS_In : URN!NodeConnection (
			source <- inNode, target <- thisModule.resolveTemp(e.LHS, 'inNode'),
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncLHS_Out : URN!NodeConnection (
			source <- thisModule.resolveTemp(e.LHS, 'outNode'), target <- outNode,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncRHS_In : URN!NodeConnection (
			source <- inNode, target <- thisModule.resolveTemp(e.RHS, 'inNode'),
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncRHS_Out : URN!NodeConnection (
			source <- thisModule.resolveTemp(e.RHS, 'outNode'), target <- outNode,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		)
}

-- 3. The OR Node (Alternative Branches)
rule CompoundOr2Nodes {
	from e : CPS!CompoundExpression (e.operator = #OR)
	to
		inNode : URN!OrFork (
			name <- 'OrSplit', diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 200, y <- e.getCourse().eContainer().courses->select(crs | crs.suggestedYear = e.getCourse().suggestedYear)->indexOf(e.getCourse()) * 150 + e.getYOffset()
		),
		outNode : URN!OrJoin (
			name <- 'OrMerge', diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString()),
			x <- 500, y <- inNode.y
		),
		ncLHS_In : URN!NodeConnection (
			source <- inNode, target <- thisModule.resolveTemp(e.LHS, 'inNode'),
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncLHS_Out : URN!NodeConnection (
			source <- thisModule.resolveTemp(e.LHS, 'outNode'), target <- outNode,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncRHS_In : URN!NodeConnection (
			source <- inNode, target <- thisModule.resolveTemp(e.RHS, 'inNode'),
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		),
		ncRHS_Out : URN!NodeConnection (
			source <- thisModule.resolveTemp(e.RHS, 'outNode'), target <- outNode,
			diagram <- thisModule.resolveTemp(e.getCourse().eContainer(), 'map' + e.getCourse().suggestedYear.toString())
		)
}


rule Student2ScenarioDef {
	from
		s: CPS!Student
	to
		scen: URN!ScenarioDef (
			name <- s.name,
			
			-- 1. Set the variables (State)
			initializations <- CPS!Course.allInstances() -> collect(c | thisModule.CreateInit(s, c)),
			
			-- 2. Trigger the start dots (Execution)
			startPoints <- CPS!Course.allInstances() -> collect(c | thisModule.CreateScenarioStart(c))
		)
}


rule CreateScenarioStart(course: CPS!Course) {
	to
		ssp: URN!ScenarioStartPoint (
			enabled <- true,
			-- ATL Magic: This looks up the 'start' node regardless of whether 
			-- the course had prerequisites or not!
			startPoint <- thisModule.resolveTemp(course, 'start')
		)
	do {
		ssp;
	}
}



rule CreateInit(student: CPS!Student, course: CPS!Course) {
	to
		init: URN!Initialization (
			-- Check if this specific course is inside the student's takenCourses list
			value <- if student.takenCourses -> includes(course) then
					'true'
				else
					'false'
				endif,
			variable <- course
		)
	do {
		init;
	}
}
